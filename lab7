Q1
#include<stdio.h>
#include<stdlib.h>
typedef struct node
{
	int key;
	struct node *left;
	struct node *right;
	int height;
}node;

int height(node *n)
{
	if(n==NULL)
		return 0;                                    
	return n->height;
}

int max(int a,int b)
{
	return(a>b)?a:b;
}

node* newnode(int key)
{
	node* n=(node*)malloc(sizeof(struct node));
	n->key=key;
	n->left=NULL;
	n->right=NULL;
	n->height=1;
	return n;
}

node* rightrotate(node *y)
{
	node* x=y->left;
	node* T2=x->right;
	x->right=y;
	y->left=T2;
	y->height=max(height(y->left),height(y->right))+1;
	x->height=max(height(x->left),height(x->right))+1;
	return x;
}

node* leftrotate(node *x)
{
	node *y=x->right;
	node *T2=y->left;
	y->left=x;
	x->right=T2;
	x->height=max(height(x->left),height(x->right))+1;
	y->height=max(height(y->left),height(y->right))+1;
	return y;
}

int balfac(node* n)
{
	if(n==NULL)
		return 0;
	return height(n->left)-height(n->right);
}

node* insert(node*node,int key)
{
	if(node==NULL)
		return(newnode(key));
	if(key<node->key)
		node->left=insert(node->left,key);
	else if(key>node->key)
		node->right=insert(node->right,key);
	else
		return node;
	node->height=1+max(height(node->left),height(node->right));
	int balance=balfac(node);
	if(balance>1&&key<node->left->key)
		return rightrotate(node);
	if(balance<-1&&key>node->right->key)
		return leftrotate(node);
	if(balance>1&&key>node->left->key)
	{
		node->left=leftrotate(node->left);
		return rightrotate(node);
	}
	if(balance<-1&&key<node->right->key)
	{
		node->right=rightrotate(node->right);
		return leftrotate(node);
	}
	return node;
}

void preorder(node* root)
{
	if(root!=NULL)
	{
		printf("%d ", root->key );
		preorder(root->left);
		preorder(root->right);
	}
}

int main()
{
	node* root=NULL;
	root=insert(root,10);
	root=insert(root,20);
	root=insert(root,30);
	root=insert(root,40);
	root=insert(root,50);
	root=insert(root,25);
	printf("preorder of the constructed AVL tree is:\n");
	preorder(root);
	return 0;
}

===============================================================================
Q2
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
    int key;
    struct node *left, *right, *parent;
    int height;
} node;

// Utility function to get the height of the tree
int height(node *N) {
    if (N == NULL)
        return 0;
    return N->height;
}

// Utility function to get maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Helper function to create a new node
node* newnode(int key) {
    node* node = (struct node*)malloc(sizeof(struct node));
    node->key = key;
    node->left = NULL;
    node->right = NULL;
    node->parent = NULL; // Initialize parent as NULL
    node->height = 1; // new node is initially added at leaf
    return node;
}

// A utility function to right rotate subtree rooted with y
node *rightRotate(node *y) {
    node *x = y->left;
    node *T2 = x->right;

    // Perform rotation
    x->right = y;
    y->left = T2;

    // Update parents
    if (T2 != NULL) T2->parent = y;
    x->parent = y->parent;
    y->parent = x;

    // Update heights
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    // Return new root
    return x;
}

// A utility function to left rotate subtree rooted with x
node *leftRotate(node *x) {
    node *y = x->right;
    node *T2 = y->left;

    // Perform rotation
    y->left = x;
    x->right = T2;

    // Update parents
    if (T2 != NULL) T2->parent = x;
    y->parent = x->parent;
    x->parent = y;

    // Update heights
    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;

    // Return new root
    return y;
}

// Get Balance factor of node N
int getBalance(node *N) {
    if (N == NULL)
        return 0;
    return height(N->left) - height(N->right);
}

// Recursive function to do preorder traversal of the tree
void preorder(node *root) {
    if (root != NULL) {
        printf("%d ", root->key);
        preorder(root->left);
        preorder(root->right);
    }
}

node* insertIteratively(node **root, int key) {
    // Part 1 - Perform normal BST insert
    if (*root == NULL) {
        *root = newnode(key);
        return *root;
    }

    node *current = *root;
    node *parent = NULL;
    while (current != NULL) {
        parent = current;
        if (key < current->key)
            current = current->left;
        else if (key > current->key)
            current = current->right;
        else // Duplicate keys not allowed
            return *root;
    }

    node *newNode = newnode(key);
    newNode->parent = parent; // Set parent of new node
    if (key < parent->key)
        parent->left = newNode;
    else
        parent->right = newNode;

    // Part 2 - Update the height of the ancestor nodes
    node *temp = newNode;
    while (parent != NULL) {
        parent->height = 1 + max(height(parent->left), height(parent->right));

        int balance = getBalance(parent);

        // If this node becomes unbalanced, then there are 4 cases

        // Left Left Case
        if (balance > 1 && key < parent->left->key)
            return rightRotate(parent);

        // Right Right Case
        if (balance < -1 && key > parent->right->key)
            return leftRotate(parent);

        // Left Right Case
        if (balance > 1 && key > parent->left->key) {
            parent->left = leftRotate(parent->left);
            return rightRotate(parent);
        }

        // Right Left Case
        if (balance < -1 && key < parent->right->key) {
            parent->right = rightRotate(parent->right);
            return leftRotate(parent);
        }

        temp = parent;
        parent = parent->parent;
    }

    // Return the (unchanged) node pointer
    return *root;
}

// Main function demonstrating iterative insertion
int main() {
    node *root = NULL;

    insertIteratively(&root, 10);
    insertIteratively(&root, 20);
    insertIteratively(&root, 30);
    insertIteratively(&root, 40);
    insertIteratively(&root, 50);
    insertIteratively(&root, 25);

    printf("Preorder traversal of the constructed AVL tree is:\n");
    preorder(root);

    return 0;
